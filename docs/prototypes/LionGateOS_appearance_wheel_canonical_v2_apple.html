<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LionGateOS — Appearance Wheel (Canonical)</title>
  <style>
    :root{
      --bg0:#070813;
      --bg1:#0a0b1a;
      --card:#0c0f22cc;
      --card2:#0a0c1b99;
      --stroke:#ffffff1a;
      --stroke2:#7aa2ff55;
      --text:#eaf0ff;
      --muted:#a8b5de;
      --muted2:#7f8bb4;
      --accent:#6f9bff;
      --accent2:#9db7ff;
      --shadow: 0 22px 60px rgba(0,0,0,.55);
      --radius: 22px;
      --wheelH: 260px;
      --itemH: 54px;
    }

    *{box-sizing:border-box;}
    html,body{height:100%;}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 18% 22%, rgba(99,122,255,.26), transparent 60%),
        radial-gradient(900px 700px at 78% 58%, rgba(149,85,255,.14), transparent 55%),
        radial-gradient(700px 700px at 50% 110%, rgba(70,120,255,.12), transparent 50%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 65%, #050611);
      overflow:hidden;
    }

    /* Minimal, non-glowy scrollbar in case any container ever overflows */
    *::-webkit-scrollbar{width:10px;height:10px;}
    *::-webkit-scrollbar-track{background:rgba(255,255,255,.04); border-radius:10px;}
    *::-webkit-scrollbar-thumb{background:rgba(111,155,255,.25); border-radius:10px; border:2px solid rgba(0,0,0,.35);} 
    *::-webkit-scrollbar-thumb:hover{background:rgba(111,155,255,.35);} 

    .stage{
      height:100%;
      display:grid;
      place-items:center;
      padding:24px;
    }

    .card{
      width:min(520px, 92vw);
      background: linear-gradient(180deg, rgba(18,22,48,.78), rgba(10,12,27,.72));
      border:1px solid var(--stroke);
      border-radius: calc(var(--radius) + 6px);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding:22px;
      position:relative;
    }

    .card::before{
      content:"";
      position:absolute;
      inset: -1px;
      border-radius: calc(var(--radius) + 7px);
      pointer-events:none;
      background: radial-gradient(600px 280px at 30% 10%, rgba(111,155,255,.22), transparent 55%),
                  radial-gradient(520px 260px at 70% 100%, rgba(170,125,255,.14), transparent 55%);
      opacity:.9;
      mix-blend-mode: screen;
    }

    .header{position:relative; z-index:1;}
    .title{
      font-size:28px;
      font-weight:750;
      letter-spacing:.2px;
      margin:0;
    }
    .subtitle{
      margin:6px 0 0;
      color:var(--muted);
      font-size:14px;
      line-height:1.35;
    }

    .panel{
      position:relative;
      z-index:1;
      margin-top:18px;
      background: linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.10));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding:18px 16px 16px;
      overflow:hidden;
    }

    .panel::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(300px 160px at 20% 15%, rgba(111,155,255,.10), transparent 55%),
        radial-gradient(360px 220px at 85% 90%, rgba(162,120,255,.08), transparent 60%);
      opacity:1;
    }

    .activeName{
      position:relative;
      z-index:2;
      text-align:center;
      font-size:18px;
      font-weight:700;
      letter-spacing:.2px;
      margin:2px 0 10px;
      color:var(--text);
    }

    .wheelWrap{
      position:relative;
      z-index:2;
      height: var(--wheelH);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.08));
      overflow:hidden;
      user-select:none;
      -webkit-user-select:none;
      touch-action: pan-y;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 10px;
    }

    /* Center selection "slot" */
    .slot{
      position:absolute;
      left: 12px;
      right: 12px;
      height: var(--itemH);
      border-radius: 16px;
      border: 1px solid rgba(111,155,255,.40);
      background: rgba(111,155,255,.06);
      box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
      pointer-events:none;
      top: 50%;
      transform: translateY(-50%);
    }

    .fadeTop, .fadeBot{
      position:absolute;
      left:0; right:0;
      height: 72px;
      pointer-events:none;
      z-index:3;
    }
    .fadeTop{top:0; background: linear-gradient(180deg, rgba(11,12,26,1), rgba(11,12,26,0));}
    .fadeBot{bottom:0; background: linear-gradient(0deg, rgba(11,12,26,1), rgba(11,12,26,0));}

    .wheel{
      position:relative;
      width: 100%;
      height: 100%;
      perspective: 900px;
      transform-style: preserve-3d;
    }

    .item{
      position:absolute;
      left: 10px;
      right: 10px;
      height: var(--itemH);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 17px;
      font-weight:650;
      letter-spacing:.15px;
      color: rgba(234,240,255,.60);
      text-shadow: 0 10px 22px rgba(0,0,0,.45);
      border-radius: 14px;
      cursor: default;
      will-change: transform, opacity, filter;
    }

    .item.isActive{
      color: rgba(234,240,255,.98);
      text-shadow: 0 14px 28px rgba(0,0,0,.55);
      filter: drop-shadow(0 0 18px rgba(111,155,255,.22));
    }

    .controls{
      position:relative;
      z-index:2;
      margin-top:14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .sliderRow{
      display:flex;
      align-items:center;
      gap:12px;
    }

    .range{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(111,155,255,.95), rgba(111,155,255,.12));
      outline:none;
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 24px rgba(0,0,0,.30) inset;
    }

    .range::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.85), rgba(219,232,255,.35) 35%, rgba(111,155,255,.55) 70%, rgba(111,155,255,.85));
      border: 1px solid rgba(255,255,255,.18);
      box-shadow:
        0 10px 24px rgba(0,0,0,.35),
        0 0 0 3px rgba(111,155,255,.18);
      cursor: pointer;
    }

    .range::-moz-range-thumb{
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.85), rgba(219,232,255,.35) 35%, rgba(111,155,255,.55) 70%, rgba(111,155,255,.85));
      border: 1px solid rgba(255,255,255,.18);
      box-shadow:
        0 10px 24px rgba(0,0,0,.35),
        0 0 0 3px rgba(111,155,255,.18);
      cursor: pointer;
    }

    .meta{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted2);
      font-size: 13px;
      line-height:1.25;
    }

    .valuePill{
      color: rgba(234,240,255,.90);
      font-weight:700;
    }

    .foot{
      position:relative;
      z-index:1;
      margin-top:14px;
      color: rgba(168,181,222,.70);
      font-size: 12px;
      text-align:center;
    }

    @media (max-width:420px){
      :root{ --wheelH: 240px; --itemH: 52px; }
      .title{font-size:24px;}
      .item{font-size:16px;}
    }
  

/* ---- Apple-like cylindrical wheel perception tweaks (v2) ---- */
:root{
  --wheelPerspective: 1100px;
}
.wheelWrap{
  perspective: var(--wheelPerspective) !important;
}
.wheel{
  transform-style: preserve-3d !important;
}
.item{
  top: 50% !important;
  left: 0;
  right: 0;
  transform-origin: 50% 50%;
  backface-visibility: hidden;
  will-change: transform, opacity;
}
</style>
</head>
<body>
  <div class="stage">
    <div class="card" role="application" aria-label="LionGateOS Appearance Wheel (Canonical)">
      <div class="header">
        <h1 class="title">Appearance</h1>
        <p class="subtitle">Select a parameter (wheel), then adjust its value (slider). Wheel locks selection on release and snaps to the nearest item.</p>
      </div>

      <div class="panel">
        <div class="activeName" id="activeName">Glow</div>

        <div class="wheelWrap" id="wheelWrap" aria-label="Appearance parameter selector">
          <div class="fadeTop"></div>
          <div class="fadeBot"></div>
          <div class="slot" aria-hidden="true"></div>
          <div class="wheel" id="wheel"></div>
        </div>

        <div class="controls">
          <div class="sliderRow">
            <input class="range" id="valueSlider" type="range" min="0" max="100" step="1" aria-label="Parameter value" />
          </div>
          <div class="meta">
            <div>Locked parameter: <span class="valuePill" id="lockedLabel">Glow</span></div>
            <div><span class="valuePill" id="valueLabel">Glow: 50</span></div>
          </div>
        </div>
      </div>

      <div class="foot">Canonical demo — one wheel (parameter) + one slider (value). No other behavior.</div>
    </div>
  </div>

<script>
(() => {
  // Canonical: one wheel selects PARAMETER, one slider adjusts VALUE (0-100).
  // Look-and-feel stays consistent; only wheel motion/math is improved to feel cylindrical.

  const PARAMETERS = [
    { key: 'speed',      label: 'Speed' },
    { key: 'particles',  label: 'Particles' },
    { key: 'brightness', label: 'Brightness' },
    { key: 'glow',       label: 'Glow' },
    { key: 'sharpness',  label: 'Sharpness' },
    { key: 'color',      label: 'Color' },
    { key: 'size',       label: 'Size' },
  ];

  // Values per parameter (0-100)
  const values = Object.create(null);
  PARAMETERS.forEach(p => values[p.key] = 50);

  // Start at Glow
  let activeIndex = PARAMETERS.findIndex(p => p.key === 'glow');
  if (activeIndex < 0) activeIndex = 0;

  // Elements
  const wheelWrap   = document.getElementById('wheelWrap');
  const wheel       = document.getElementById('wheel');
  const activeName  = document.getElementById('activeName');
  const lockedLabel = document.getElementById('lockedLabel');
  const valueLabel  = document.getElementById('valueLabel');
  const slider      = document.getElementById('valueSlider');

  const N = PARAMETERS.length;
  const REPEATS = 5;               // repeating the list avoids hitting edges
  const BASE = Math.floor(REPEATS/2) * N;
  const TOTAL = N * REPEATS;

  // Read CSS var --itemH
  const readItemH = () => {
    const v = getComputedStyle(document.documentElement).getPropertyValue('--itemH').trim();
    const n = parseFloat((v || '').replace('px',''));
    return Number.isFinite(n) && n > 10 ? n : 54;
  };

  let itemH = readItemH();

  // Cylinder geometry
  // Angle per step: smaller = smoother cylinder; too small = "wave".
  // 20deg is a common wheel feel; keep consistent across devices.
  const STEP_DEG = 20;

  const deg2rad = d => d * Math.PI / 180;
  const radiusFor = (itemH) => {
    const half = itemH / 2;
    const a = deg2rad(STEP_DEG / 2);
    const t = Math.tan(a);
    return t > 1e-6 ? (half / t) : 160;
  };

  let radius = radiusFor(itemH);

  // Build items (repeated)
  const items = [];
  wheel.innerHTML = '';
  for (let r=0; r<REPEATS; r++){
    for (let i=0; i<N; i++){
      const p = PARAMETERS[i];
      const el = document.createElement('div');
      el.className = 'item';
      el.textContent = p.label;
      el.setAttribute('role','option');
      el.dataset.absIndex = String(r*N + i);
      el.dataset.key = p.key;
      wheel.appendChild(el);
      items.push(el);
    }
  }

  // Offset in "item units"; keep centered around BASE+activeIndex
  let offset = (BASE + activeIndex) * itemH;

  // Drag
  let dragging = false;
  let dragStartY = 0;
  let offsetStart = 0;
  let lastY = 0;
  let lastT = 0;
  let velocity = 0;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  const absIndexFromOffset = (off) => {
    const idx = Math.round(off / itemH);
    return clamp(idx, 0, TOTAL-1);
  };

  const activeIndexFromAbs = (absIdx) => {
    const m = absIdx % N;
    return m < 0 ? m + N : m;
  };

  const setActive = (idx) => {
    activeIndex = idx;
    const p = PARAMETERS[activeIndex];
    activeName.textContent = p.label;
    lockedLabel.textContent = p.label;
    slider.value = String(values[p.key]);
    valueLabel.textContent = `${p.label}: ${values[p.key]}`;
  };

  const setValueForActive = (v) => {
    const p = PARAMETERS[activeIndex];
    values[p.key] = v;
    slider.value = String(v);
    valueLabel.textContent = `${p.label}: ${v}`;
  };

  slider.addEventListener('input', () => {
    const v = clamp(parseInt(slider.value, 10) || 0, 0, 100);
    setValueForActive(v);
  });

  // Render cylindrical wheel
  const render = () => {
    // Sync geometry to responsive changes
    const newH = readItemH();
    if (Math.abs(newH - itemH) > 0.5){
      itemH = newH;
      radius = radiusFor(itemH);
      // keep same selected abs index visually
      const absIdx = absIndexFromOffset(offset);
      offset = absIdx * itemH;
    }

    const centerFloat = offset / itemH;
    const nearestAbs = absIndexFromOffset(offset);
    const nearestActive = activeIndexFromAbs(nearestAbs);

    // Highlight should always represent the nearest item to the slot.
    // This fixes the "locked is centered but another is highlighted" issue.
    if (dragging){
      // During drag, preview selection by nearest.
      const p = PARAMETERS[nearestActive];
      activeName.textContent = p.label;
      lockedLabel.textContent = p.label;
      valueLabel.textContent = `${p.label}: ${values[p.key]}`;
      slider.value = String(values[p.key]);
    }

    for (let abs=0; abs<TOTAL; abs++){
      const el = items[abs];
      const rel = abs - centerFloat;
      const angle = rel * STEP_DEG;

      // Fade/scale with angle; clamp for stability
      const a = Math.max(-90, Math.min(90, angle));
      const absA = Math.abs(a);
      const opacity = 1 - (absA / 90) * 0.78;
      const scale = 1 - (absA / 90) * 0.18;

      el.style.opacity = String(Math.max(0.08, opacity));
      el.style.transform = `translateY(-50%) rotateX(${a}deg) translateZ(${radius}px) scale(${scale})`;
      el.style.zIndex = String(1000 - Math.round(absA * 6));

      const isNearest = abs === nearestAbs;
      el.classList.toggle('active', isNearest);
    }

    // Keep the wheel inside a stable range by recentring when not dragging
    // (so you never hit the edges)
    if (!dragging){
      const absIdx = nearestAbs;
      const targetAbs = BASE + activeIndexFromAbs(absIdx);
      // Only recenter if we drifted far from the middle band
      if (Math.abs(absIdx - targetAbs) > N){
        offset = targetAbs * itemH;
      }
    }
  };

  // Smooth snap animation
  const animateTo = (targetOffset) => {
    const start = offset;
    const delta = targetOffset - start;
    const dur = 180; // ms
    const t0 = performance.now();

    const easeOut = (t) => 1 - Math.pow(1 - t, 3);

    const tick = (t) => {
      const p = Math.min(1, (t - t0) / dur);
      offset = start + delta * easeOut(p);
      render();
      if (p < 1) requestAnimationFrame(tick);
    };

    requestAnimationFrame(tick);
  };

  const onDown = (clientY) => {
    dragging = true;
    dragStartY = clientY;
    offsetStart = offset;
    lastY = clientY;
    lastT = performance.now();
    velocity = 0;
  };

  const onMove = (clientY) => {
    if (!dragging) return;
    const dy = clientY - dragStartY;
    offset = clamp(offsetStart - dy, 0, (TOTAL-1) * itemH);

    // velocity (for optional inertial feel)
    const now = performance.now();
    const dt = now - lastT;
    if (dt > 0){
      const v = (lastY - clientY) / dt; // px per ms
      velocity = 0.85 * velocity + 0.15 * v;
      lastY = clientY;
      lastT = now;
    }

    render();
  };

  const onUp = () => {
    if (!dragging) return;
    dragging = false;

    // Inertia: a light throw based on velocity, then snap
    const throwPx = velocity * 220; // tune
    offset = clamp(offset + throwPx, 0, (TOTAL-1) * itemH);

    const absIdx = absIndexFromOffset(offset);
    const idx = activeIndexFromAbs(absIdx);
    setActive(idx);

    const targetAbs = BASE + idx;
    const target = targetAbs * itemH;
    animateTo(target);
  };

  // Pointer + touch
  wheelWrap.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    wheelWrap.setPointerCapture(e.pointerId);
    onDown(e.clientY);
    render();
  }, { passive: false });

  wheelWrap.addEventListener('pointermove', (e) => {
    onMove(e.clientY);
  });

  wheelWrap.addEventListener('pointerup', () => onUp());
  wheelWrap.addEventListener('pointercancel', () => onUp());
  wheelWrap.addEventListener('lostpointercapture', () => onUp());

  // Mouse wheel scroll (desktop)
  wheelWrap.addEventListener('wheel', (e) => {
    e.preventDefault();
    const dy = e.deltaY;
    offset = clamp(offset + dy, 0, (TOTAL-1) * itemH);
    dragging = true;
    render();
    dragging = false;
    const absIdx = absIndexFromOffset(offset);
    const idx = activeIndexFromAbs(absIdx);
    setActive(idx);
    animateTo((BASE + idx) * itemH);
  }, { passive: false });

  // Resize safety
  const ro = new ResizeObserver(() => { render(); });
  ro.observe(document.documentElement);

  // Initial state
  setActive(activeIndex);
  slider.value = String(values[PARAMETERS[activeIndex].key]);
  render();
})();
</script>
</body>
</html>
