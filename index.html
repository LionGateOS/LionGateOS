<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="theme-color" content="#0b0f1a"/>
<title>LionGateOS</title>

<script>
/* LGOS Phase 9: global single-init guard */
try{
  if(window.__LGOS_HARDENED__){ /* already initialized */ }
  else { window.__LGOS_HARDENED__ = true; }
}catch(e){}


/* LGOS Phase 9: OS hardening markers (non-visual) */
(function(){try{
  var h=document.documentElement;
  h.dataset.osVersion = h.dataset.osVersion || "9.0";
  h.dataset.osBuild   = h.dataset.osBuild   || "20251223-125124Z";
  h.dataset.osState   = h.dataset.osState   || "initializing";
}catch(e){}})();
</script>


<style>
:root{
  --bg:#070a12;
  --card:rgba(14,18,34,.78);
  --text:#e8edf7;
  --muted:#aab6d6;
  --trace:#5aa0ff;          /* electric blue */
  --radius:26px;
  --stroke:2px;
}

html,body{
  margin:0;height:100%;
  background:var(--bg);
  color:var(--text);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
}
.hidden{display:none!important}

/* Ambient background */
#ambient{
  position:fixed;inset:0;z-index:0;pointer-events:none;
  background:
    radial-gradient(900px 600px at 20% 20%, rgba(90,160,255,.10), transparent 60%),
    radial-gradient(900px 650px at 85% 55%, rgba(215,179,90,.08), transparent 65%),
    url("assets/ambient_purple.png");
  background-size:cover;
  background-position:center;
  opacity:.34;
}

/* Sparkles */
#sparkles{position:fixed;inset:0;z-index:1;pointer-events:none}
.dot{
  position:absolute;
  width:4px;height:4px;border-radius:50%;
  background:rgba(140,180,255,.95);
  box-shadow:0 0 14px rgba(140,180,255,.95);
  animation:floatUp linear infinite;
}
@keyframes floatUp{
  from{transform:translateY(0)}
  to{transform:translateY(-160vh)}
}

/* Splash */
#splash{
  position:fixed;inset:0;z-index:9999;background:#000;
  display:flex;align-items:center;justify-content:center;
}
#splash.hide{display:none}
#splash video{width:100%;height:100%;object-fit:contain}

/* Gateway */
#gateway{
  position:relative;z-index:2;
  min-height:100%;
  display:flex;align-items:center;justify-content:center;
  padding:40px;
}
.panel{
  max-width:1100px;width:100%;
  display:grid;grid-template-columns:1fr 1fr;gap:24px;
}
@media(max-width:900px){.panel{grid-template-columns:1fr}}

.card{
  position:relative;
  background:var(--card);
  border-radius:var(--radius);
  box-shadow:0 22px 60px rgba(0,0,0,.55);
  overflow:hidden;
  padding:30px;
}

.edgeRunner{position:absolute;inset:0;pointer-events:none;z-index:5}
.edgeRunner svg{width:100%;height:100%;display:block}

.logo{max-width:420px;width:100%;display:block}
footer{margin-top:22px;font-size:12px;color:var(--muted)}

.launcher{display:flex;flex-direction:column;gap:14px}
.launcher a{
  display:flex;align-items:center;justify-content:space-between;
  padding:18px;border-radius:18px;border:1px solid rgba(255,255,255,.14);
  text-decoration:none;color:#fff;
}
.launcher a.disabled{opacity:.5;pointer-events:none}

@media (prefers-reduced-motion: reduce){
  #sparkles{display:none}
}
</style>

<link rel="icon" href="/favicon.ico"/>
<link rel="icon" sizes="32x32" type="image/png" href="/favicon-32.png"/>
<link rel="apple-touch-icon" sizes="180x180" href="/favicon-180.png"/>
<link rel="icon" sizes="256x256" type="image/png" href="/favicon-256.png"/>
</head>

<body>
<div id="ambient"></div>
<div id="sparkles" aria-hidden="true"></div>

<div id="splash">
  <video autoplay muted playsinline id="splashVideo" preload="none">
    <source src="assets/splash.mp4?v=lgos-splash-20251222" type="video/mp4"/>
  </video>
</div>

<div id="gateway" class="hidden">
  <div class="panel">
    <div class="card" id="cardLeft">
      <div class="edgeRunner" aria-hidden="true">
        <svg id="svgLeft"></svg>
      </div>
      <img class="logo" src="assets/liongateos_logo.png" alt="LionGateOS"/>
      <footer>© <span id="year"></span> LionGateOS</footer>
    </div>

    <div class="card launcher" id="cardRight">
      <div class="edgeRunner" aria-hidden="true">
        <svg id="svgRight"></svg>
      </div>
      <a data-app-id="enter-os" data-app-status="soon" class="disabled"><span>Enter LionGateOS</span><span>Coming soon</span></a>
      <a class="disabled"><span>App Store</span><span>Coming soon</span></a>
      <a class="disabled"><span>AI Tools</span><span>Coming soon</span></a>

      <a data-app-id="smartquote-ai" data-app-status="live" href="https://smartquoteai.pro" target="_blank" rel="noopener"><span>SmartQuote AI</span><span>Open</span></a>
      <a data-app-id="liongateos-travels" data-app-status="live" href="https://liongateostravels.com" target="_blank" rel="noopener"><span>LionGateOS Travels</span><span>Open</span></a>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Splash (unchanged behavior)
   ========================================================= */
const KEY="lgos_splash_seen_v11";
const splash=document.getElementById("splash");
const gateway=document.getElementById("gateway");
const video=document.getElementById("splashVideo");
document.getElementById("year").textContent = new Date().getFullYear();

function showGateway(){
  splash.classList.add("hide");
  gateway.classList.remove("hidden");
  startOS();
}

if (localStorage.getItem(KEY)) {
  showGateway();
} else {
  video.addEventListener("ended", ()=>{ localStorage.setItem(KEY,"1"); showGateway(); });
  // Safety: if video can't autoplay, allow click to proceed
  video.addEventListener("error", ()=>{ localStorage.setItem(KEY,"1"); showGateway(); });
}

/* =========================================================
   Sparkles (kept as-is: visible, premium)
   ========================================================= */
(function initSparkles(){
  const c = document.getElementById("sparkles");
  if(!c || c.children.length) return;
  const COUNT = 28; // visible but controlled
  for(let i=0;i<COUNT;i++){
    const d=document.createElement("div");
    d.className="dot";
    d.style.left = (Math.random()*100) + "vw";
    d.style.bottom = (-30 - Math.random()*260) + "px";
    d.style.opacity = (0.35 + Math.random()*0.55).toFixed(2);
    d.style.animationDuration = (14 + Math.random()*18).toFixed(2) + "s";
    d.style.animationDelay = (-Math.random()*18).toFixed(2) + "s";
    c.appendChild(d);
  }
})();

/* =========================================================
   Tracers — FINAL GOVERNED IMPLEMENTATION
   Rules enforced:
   - One direction per card (left cw, right ccw)
   - 1 or 2 tracers per card (occasionally 2)
   - Tracer segment length: 12%–25% of perimeter
   - Each lap travel distance: 90%–100% of perimeter before reseed
   - Two tracers never touch (constant separation enforced)
   - Same brightness
   - Single controller clock per card (no competing loops)
   - Layout-stable init to avoid first-load "wrong path until refresh"
   ========================================================= */

/* Utility: build a rounded-rect path 'd' that matches the card radius */
function roundedRectPath(w, h, r, inset){
  const x = inset, y = inset;
  const W = Math.max(1, w - inset*2);
  const H = Math.max(1, h - inset*2);
  const rr = Math.max(0, Math.min(r, Math.min(W, H)/2));
  // Clockwise path starting top-left corner (after radius)
  return [
    `M ${x+rr} ${y}`,
    `H ${x+W-rr}`,
    `A ${rr} ${rr} 0 0 1 ${x+W} ${y+rr}`,
    `V ${y+H-rr}`,
    `A ${rr} ${rr} 0 0 1 ${x+W-rr} ${y+H}`,
    `H ${x+rr}`,
    `A ${rr} ${rr} 0 0 1 ${x} ${y+H-rr}`,
    `V ${y+rr}`,
    `A ${rr} ${rr} 0 0 1 ${x+rr} ${y}`,
    "Z"
  ].join(" ");
}

/* Wait until the card's layout stops changing (prevents first-load misalignment) */
function waitForStableBox(el, opts){
  const {frames=6, maxMs=1800} = (opts||{});
  return new Promise((resolve)=>{
    let stable=0;
    let last=null;
    const start=performance.now();

    function sample(){
      const r=el.getBoundingClientRect();
      const cur=[Math.round(r.width), Math.round(r.height)];
      if(last && cur[0]===last[0] && cur[1]===last[1] && cur[0]>0 && cur[1]>0){
        stable++;
      } else {
        stable=0;
        last=cur;
      }

      if(stable>=frames || (performance.now()-start)>maxMs){
        resolve({w:cur[0], h:cur[1]});
        return;
      }
      requestAnimationFrame(sample);
    }
    requestAnimationFrame(sample);
  });
}

function createSvgPaths(svg, d, strokePx){
  svg.innerHTML = "";
  const NS="http://www.w3.org/2000/svg";

  const base=document.createElementNS(NS,"path");
  base.setAttribute("d", d);
  base.setAttribute("fill","none");
  base.setAttribute("stroke","rgba(255,255,255,.12)");
  base.setAttribute("stroke-width", Math.max(1, strokePx-0.5));
  base.setAttribute("stroke-linejoin","round");
  base.setAttribute("stroke-linecap","round");
  base.setAttribute("vector-effect","non-scaling-stroke");

  svg.appendChild(base);

  // Runner paths (1 or 2) added later by controller
  return base;
}

/* Controller per card */
function TracerController(cfg){
  const card = cfg.card;
  const svg  = cfg.svg;
  const dir  = cfg.dir; // +1 or -1
  const radius = cfg.radius;
  const stroke = cfg.stroke;

  let L = 0;          // true perimeter length from SVG path
  let runners = [];   // runner objects
  let rafId = null;
  let t0 = 0;

  function build(){
    // Measure card at final size
    const r = card.getBoundingClientRect();
    const w = Math.max(1, Math.round(r.width));
    const h = Math.max(1, Math.round(r.height));

    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    svg.setAttribute("preserveAspectRatio", "none");

    const inset = stroke/2;
    const d = roundedRectPath(w, h, radius, inset);

    createSvgPaths(svg, d, stroke);

    // Create runner path(s)
    const NS="http://www.w3.org/2000/svg";

    // Always create two runner paths, but we can disable 2nd per lap
    const p1=document.createElementNS(NS,"path");
    const p2=document.createElementNS(NS,"path");
    [p1,p2].forEach(p=>{
      p.setAttribute("d", d);
      p.setAttribute("fill","none");
      p.setAttribute("stroke", getComputedStyle(document.documentElement).getPropertyValue('--trace').trim() || "#5aa0ff");
      p.setAttribute("stroke-width", stroke);
      p.setAttribute("stroke-linejoin","round");
      p.setAttribute("stroke-linecap","round");
      p.setAttribute("vector-effect","non-scaling-stroke");
      // A little glow without changing color system-wide
      p.style.filter = "drop-shadow(0 0 10px rgba(90,160,255,.55))";
      svg.appendChild(p);
    });

    // Get exact path length
    L = p1.getTotalLength();

    runners = [
      { path: p1, active: true, segLen: 0, start: 0, travel: 0, speed: 0, lapStartMs: 0, lapMs: 0 },
      { path: p2, active: false, segLen: 0, start: 0, travel: 0, speed: 0, lapStartMs: 0, lapMs: 0 }
    ];
  }

  function pickSegLen(){
    // 12% to 25% of perimeter
    return L * (0.12 + Math.random()*0.13);
  }

  function pickTravel(){
    // 90% to 100% of perimeter
    return L * (0.90 + Math.random()*0.10);
  }

  function normalize(x){
    // keep within [0, L)
    x = x % L;
    if(x < 0) x += L;
    return x;
  }

  function ensureSeparation(aStart, aSeg, bSeg){
    // Choose bStart far enough from aStart so segments never touch.
    // Because both run same direction at same speed, separation is constant.
    const buffer = L * 0.03; // 3% safety gap
    const minGap = aSeg + bSeg + buffer;

    // Try a few random picks; fall back to deterministic offset
    for(let i=0;i<20;i++){
      const cand = Math.random()*L;
      const dist = Math.abs(normalize(cand - aStart));
      const dist2 = L - dist;
      const gap = Math.min(dist, dist2);
      if(gap >= minGap) return cand;
    }
    return normalize(aStart + minGap);
  }

  function applyDash(path, segLen){
    // One bright segment; rest gap
    path.setAttribute("stroke-dasharray", `${segLen} ${Math.max(1, L - segLen)}`);
  }

  function seedLap(nowMs){
    // Decide whether we have one or two runners for this lap window
    const wantTwo = Math.random() < 0.30; // occasional
    runners[0].active = true;
    runners[1].active = wantTwo;

    // Shared speed per card to keep runners from colliding
    // Units: length units per ms
    const baseSpeed = (L / 9000) * (0.85 + Math.random()*0.35); // ~9–6.5s per full loop-ish
    const speed = baseSpeed * dir;

    // Runner 1
    runners[0].segLen = pickSegLen();
    runners[0].start  = Math.random()*L;
    runners[0].travel = pickTravel();
    runners[0].speed  = speed;
    runners[0].lapStartMs = nowMs;
    runners[0].lapMs  = Math.max(4000, Math.abs(runners[0].travel / speed)); // ms to travel distance

    applyDash(runners[0].path, runners[0].segLen);

    // Runner 2 (if active)
    if(runners[1].active){
      runners[1].segLen = pickSegLen();
      runners[1].start  = ensureSeparation(runners[0].start, runners[0].segLen, runners[1].segLen);
      runners[1].travel = pickTravel();
      runners[1].speed  = speed;
      runners[1].lapStartMs = nowMs;
      runners[1].lapMs  = Math.max(4000, Math.abs(runners[1].travel / speed));
      runners[1].path.style.opacity = "1"; // same brightness
      applyDash(runners[1].path, runners[1].segLen);
    } else {
      runners[1].path.style.opacity = "0"; // hidden but kept in DOM
    }
  }

  function tick(nowMs){
    // Seed at start
    if(!t0){
      t0 = nowMs;
      seedLap(nowMs);
    }

    // Determine if we need a new lap (only when BOTH active runners have completed >=90% travel)
    let lapDone = true;
    for(const r of runners){
      if(!r.active) continue;
      const elapsed = nowMs - r.lapStartMs;
      if(elapsed < r.lapMs) lapDone = false;
    }
    if(lapDone){
      seedLap(nowMs);
    }

    // Update positions (smooth)
    for(const r of runners){
      if(!r.active) continue;
      const elapsed = Math.min(nowMs - r.lapStartMs, r.lapMs);
      const dist = (elapsed * r.speed);
      const off = normalize(r.start + dist);
      r.path.setAttribute("stroke-dashoffset", off);
    }

    rafId = requestAnimationFrame(tick);
  }

  async function start(){
    // Wait for stable layout BEFORE building paths
    await waitForStableBox(card, {frames: 7, maxMs: 2200});
    build();

    // Extra stability: after SVG is in DOM, wait 2 frames and rebuild once
    await new Promise(res=>requestAnimationFrame(()=>requestAnimationFrame(res)));
    build();

    // Start loop
    if(rafId) cancelAnimationFrame(rafId);
    t0 = 0;
    rafId = requestAnimationFrame(tick);
  }

  function stop(){
    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }

  // Rebuild on true size changes (keeps stable on resize/orientation)
  if(window.ResizeObserver){
    const ro = new ResizeObserver(()=>{
      stop();
      start();
    });
    ro.observe(card);
  } else {
    window.addEventListener("resize", ()=>{ stop(); start(); }, {passive:true});
    window.addEventListener("orientationchange", ()=>{ stop(); start(); }, {passive:true});
  }
  document.addEventListener("visibilitychange", ()=>{
    if(!document.hidden){
      stop(); start();
    }
  });

  return { start, stop };
}

/* Start tracers after gateway is shown */
function startOS(){
  startOS.__started = true;
  startOSInner();
}
async function startOSInner(){
  await new Promise(res=>requestAnimationFrame(()=>requestAnimationFrame(res)));
  const left = TracerController({ card: cardLeft, svg: svgLeft, dir:+1, radius:26, stroke:2 });
  const right = TracerController({ card: cardRight, svg: svgRight, dir:-1, radius:26, stroke:2 });
  left.start(); right.start();
}
</script>

</body>
</html>
