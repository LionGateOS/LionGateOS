<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="theme-color" content="#0b0f1a"/>
<title>LionGateOS</title>

<style>
:root{
  --bg:#070a12;
  --card:rgba(14,18,34,.78); /* LOCKED panel transparency */
  --text:#e8edf7;
  --muted:#aab6d6;
  --trace:#5aa0ff;
  --radius:26px;
  --stroke:2px;
}

html,body{
  margin:0;height:100%;
  background:var(--bg);
  color:var(--text);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
}
.hidden{display:none!important}

/* Ambient background */
#ambient{
  position:fixed;inset:0;z-index:0;pointer-events:none;
  background:
    radial-gradient(900px 600px at 20% 20%, rgba(90,160,255,.08), transparent 60%),
    radial-gradient(900px 650px at 85% 55%, rgba(215,179,90,.06), transparent 65%),
    url("assets/ambient_purple.png");
  background-size:cover;
  background-position:center;
  opacity:.30;
}
#ambient::after{
  content:"";position:absolute;inset:0;
  background:radial-gradient(70% 70% at 50% 55%, rgba(0,0,0,0), rgba(0,0,0,.55));
}

/* Sparkles */
#sparkles{position:fixed;inset:0;z-index:1;pointer-events:none;opacity:.30}
.dot{
  position:absolute;width:3px;height:3px;border-radius:50%;
  background:rgba(120,160,255,.95);
  box-shadow:0 0 12px rgba(120,160,255,.9);
  animation:floatUp 24s linear infinite;
}
@keyframes floatUp{from{transform:translateY(0)}to{transform:translateY(-140vh)}}

/* Splash */
#splash{position:fixed;inset:0;z-index:9999;background:#000;display:flex;align-items:center;justify-content:center}
#splash.hide{display:none}
#splash video{width:100%;height:100%;object-fit:contain}

/* Layout */
#gateway{position:relative;z-index:2;min-height:100%;display:flex;align-items:center;justify-content:center;padding:40px}
.panel{max-width:1100px;width:100%;display:grid;grid-template-columns:1fr 1fr;gap:24px}
@media(max-width:900px){.panel{grid-template-columns:1fr}}

/* Cards */
.card{
  position:relative;
  background:var(--card);
  border-radius:var(--radius);
  box-shadow:0 22px 60px rgba(0,0,0,.55);
  overflow:hidden;
  padding:30px;
}
.edgeRunner{position:absolute;inset:0;pointer-events:none;z-index:5}
.edgeRunner svg{width:100%;height:100%;display:block}

.logo{
  max-width:420px;
  width:100%;
  display:block;
  margin-left:auto;
  margin-right:auto;
}
footer{margin-top:22px;font-size:12px;color:var(--muted)}

/* Launcher */
.launcher{display:flex;flex-direction:column;gap:14px}
.launcher a{
  display:flex;align-items:center;justify-content:space-between;
  padding:18px;border-radius:18px;border:1px solid rgba(255,255,255,.14);
  text-decoration:none;color:#fff;
  background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.08));
}
.launcher a.disabled{opacity:.5;pointer-events:none}

@media (prefers-reduced-motion: reduce){#sparkles{display:none}}
</style>

<link rel="icon" href="/favicon.ico"/>
<link rel="icon" sizes="32x32" type="image/png" href="/favicon-32.png"/>
<link rel="apple-touch-icon" sizes="180x180" href="/favicon-180.png"/>
<link rel="icon" sizes="256x256" type="image/png" href="/favicon-256.png"/>
</head>

<body>
<div id="ambient" aria-hidden="true"></div>
<div id="sparkles" aria-hidden="true"></div>

<div id="splash">
  <video id="splashVideo" autoplay muted playsinline preload="none">
    <source src="assets/splash.mp4?v=lgos-splash-20251223" type="video/mp4"/>
  </video>
</div>

<div id="gateway" class="hidden">
  <div class="panel">

    <div class="card" id="cardLeft" style="display:flex;flex-direction:column;align-items:center;">
      <div class="edgeRunner" aria-hidden="true">
        <svg id="svgLeft"><rect id="baseLeft"/><!-- runners injected --></svg>
      </div>
      <img src="assets/liongateos_logo.png" alt="LionGateOS" class="logo"/>
      <footer>© <span id="year"></span> LionGateOS</footer>
    </div>

    <div class="card launcher" id="cardRight">
      <div class="edgeRunner" aria-hidden="true">
        <svg id="svgRight"><rect id="baseRight"/><!-- runners injected --></svg>
      </div>
      <a class="disabled"><span>Enter LionGateOS</span><span>Coming soon</span></a>
      <a href="https://smartquoteai.pro" target="_blank" rel="noopener"><span>SmartQuote AI</span><span>Open</span></a>
      <a href="https://liongateostravels.com" target="_blank" rel="noopener"><span>LionGateOS Travels</span><span>Open</span></a>
    </div>

  </div>
</div>

<script>
/* ===== Sparkles ===== */
(function(){
  const spark=document.getElementById("sparkles");
  const N=44;
  for(let i=0;i<N;i++){
    const d=document.createElement("div");
    d.className="dot";
    d.style.left=(Math.random()*100)+"vw";
    d.style.top=(110+Math.random()*120)+"vh";
    d.style.animationDelay=(Math.random()*24)+"s";
    d.style.opacity=(0.45+Math.random()*0.45).toFixed(2);
    spark.appendChild(d);
  }
})();

/* ===== Splash once per visitor ===== */
const KEY="lgos_splash_seen_v13";
const splash=document.getElementById("splash");
const gateway=document.getElementById("gateway");
const video=document.getElementById("splashVideo");
document.getElementById("year").textContent=new Date().getFullYear();

function endSplash(){
  splash.classList.add("hide");
  gateway.classList.remove("hidden");
  stabilizeLayoutThen(startEngines);
}

if(localStorage.getItem(KEY)){ endSplash(); }
else{
  video.addEventListener("ended",()=>{ localStorage.setItem(KEY,"1"); endSplash(); });
  video.addEventListener("error",()=>{ localStorage.setItem(KEY,"1"); endSplash(); }, { once:true });
}

function stabilizeLayoutThen(cb){
  function force(){
    try{
      void document.documentElement.offsetHeight;
      void document.body.offsetHeight;
      window.dispatchEvent(new Event("resize"));
      window.dispatchEvent(new Event("orientationchange"));
    }catch(e){}
  }
  requestAnimationFrame(()=>{
    force();
    requestAnimationFrame(()=>{
      force();
      setTimeout(force, 50);
      setTimeout(force, 250);
      setTimeout(force, 800);
      setTimeout(force, 1400);
      setTimeout(()=>{ try{ cb(); }catch(e){} }, 60);
    });
  });
}

/* ===== Tracer Engine (locked for smoothness + no reversals) =====
   Fixes:
   - NO back-and-forth: we never modulo dashoffset (prevents wrap "jump")
   - Constant speed (shared across all tracers on a card)
   - Same direction for all active tracers on a card
   - Direction may change ONLY when the loop is empty (no active tracers)
   - 1 or 2 tracers sometimes, but never collide
   - Each tracer runs 90%–100% of full lap
   - Length 12%–25%
   - Grow from dot -> run -> shrink to dot
*/
function createCardEngine({card, svg, base, defaultDir}){
  const traceColor = (getComputedStyle(document.documentElement).getPropertyValue('--trace').trim() || '#5aa0ff');

  let L = 1; // perimeter proxy
  let lastW=-1, lastH=-1;

  // Active tracers
  const tracers = []; // {el,start,lenPx,segPct,lapPx,speed,born,growMs,shrinkMs}
  let nextSpawnAt = 0;

  // Direction + speed are GOVERNED and shared for the whole card while active
  let dir = defaultDir;       // +1 clockwise, -1 counter
  const speed = 205;          // CONSTANT speed (premium, non-jerky)

  function applyGeometry(){
    const r = card.getBoundingClientRect();
    if(!r.width || !r.height) return;

    const w = Math.round(r.width);
    const h = Math.round(r.height);
    if(w===lastW && h===lastH) return;
    lastW=w; lastH=h;

    svg.setAttribute("viewBox", `0 0 ${r.width} ${r.height}`);
    svg.setAttribute("preserveAspectRatio", "none");

    const rad = parseFloat(getComputedStyle(card).borderTopLeftRadius) || 26;
    const stroke = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stroke')) || 2;
    const inset = stroke/2;

    const rw = Math.max(1, r.width - stroke);
    const rh = Math.max(1, r.height - stroke);

    // stable rounded-rect perimeter approximation
    L = Math.max(1, (2*(rw+rh)) - (8*rad) + (2*Math.PI*rad));

    base.setAttribute("x", inset);
    base.setAttribute("y", inset);
    base.setAttribute("width", rw);
    base.setAttribute("height", rh);
    base.setAttribute("rx", rad);
    base.setAttribute("ry", rad);
    base.setAttribute("fill", "none");
    base.setAttribute("stroke", "rgba(255,255,255,0.12)");
    base.setAttribute("stroke-width", Math.max(1, stroke-0.5));
    base.setAttribute("stroke-linecap", "round");
    base.setAttribute("stroke-linejoin", "round");
    base.setAttribute("vector-effect", "non-scaling-stroke");

    // keep existing runner rect geometry consistent
    const runners = svg.querySelectorAll("rect[data-runner='1']");
    runners.forEach(el=>{
      el.setAttribute("x", inset);
      el.setAttribute("y", inset);
      el.setAttribute("width", rw);
      el.setAttribute("height", rh);
      el.setAttribute("rx", rad);
      el.setAttribute("ry", rad);
    });
  }

  function rand(min,max){ return min + Math.random()*(max-min); }
  function distOnLoop(a,b){ const d=Math.abs(a-b); return Math.min(d, L-d); }

  function isSeparated(candidateStart, candidateLen){
    const margin = Math.max(22, L*0.04);
    for(const t of tracers){
      const minSep = (candidateLen/2) + (t.baseLen/2) + margin;
      if(distOnLoop(candidateStart, t.start) < minSep) return false;
    }
    return true;
  }

  function makeRunnerRect(){
    const r = card.getBoundingClientRect();
    const rad = parseFloat(getComputedStyle(card).borderTopLeftRadius) || 26;
    const stroke = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stroke')) || 2;
    const inset = stroke/2;
    const rw = Math.max(1, r.width - stroke);
    const rh = Math.max(1, r.height - stroke);

    const el = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    el.dataset.runner="1";
    el.setAttribute("x", inset);
    el.setAttribute("y", inset);
    el.setAttribute("width", rw);
    el.setAttribute("height", rh);
    el.setAttribute("rx", rad);
    el.setAttribute("ry", rad);
    el.setAttribute("fill", "none");
    el.setAttribute("stroke", traceColor);
    el.setAttribute("stroke-width", stroke);
    el.setAttribute("stroke-linecap", "round");
    el.setAttribute("stroke-linejoin", "round");
    el.setAttribute("vector-effect", "non-scaling-stroke");
    // subtle halo (not bursting)
    el.style.filter = "drop-shadow(0 0 6px rgba(90,160,255,.30))";
    svg.appendChild(el);
    return el;
  }

  function maybeFlipDirectionWhenEmpty(){
    // Only allowed to change direction when NOTHING is active (your rule)
    if(tracers.length !== 0) return;
    // 35% chance to flip each time the loop becomes empty
    if(Math.random() < 0.35) dir = -dir;
  }

  function spawnTracer(now){
    if(tracers.length >= 2) return;

    // If one exists, only sometimes add a second
    if(tracers.length === 1 && Math.random() > 0.38) return;

    const segPct = rand(0.12, 0.25);
    const baseLen = Math.max(1, segPct * L);
    const lapPct = rand(0.90, 1.00);
    const lapPx = lapPct * L;

    // Find a start position that won't collide
    let start = rand(0, L);
    let ok = false;
    for(let i=0;i<28;i++){
      start = rand(0, L);
      if(isSeparated(start, baseLen)){ ok=true; break; }
    }
    if(!ok) return;

    const el = makeRunnerRect();
    const growMs = 560;
    const shrinkMs = 560;

    tracers.push({
      el,
      start,
      segPct,
      baseLen,
      lapPx,
      born: now,
      growMs,
      shrinkMs
    });
  }

  function scheduleNextSpawn(now){
    nextSpawnAt = now + rand(1900, 4700);
  }

  function tick(now){
    applyGeometry();

    if(now >= nextSpawnAt){
      spawnTracer(now);
      scheduleNextSpawn(now);
    }

    for(let i=tracers.length-1;i>=0;i--){
      const t = tracers[i];
      const elapsedMs = now - t.born;
      const distPx = (elapsedMs/1000) * speed;
      const progressPx = Math.min(distPx, t.lapPx);

      // grow/hold/shrink length (subtle)
      let curLen = t.baseLen;

      if(elapsedMs < t.growMs){
        const g = Math.max(0, Math.min(1, elapsedMs / t.growMs));
        curLen = Math.max(1, t.baseLen * g);
      }

      const remainingPx = t.lapPx - progressPx;
      const remainingMs = (remainingPx / speed) * 1000;
      if(remainingMs <= t.shrinkMs){
        const s = Math.max(0, Math.min(1, remainingMs / t.shrinkMs));
        curLen = Math.max(1, t.baseLen * s);
      }

      const gap = Math.max(1, L - curLen);
      t.el.setAttribute("stroke-dasharray", `${curLen} ${gap}`);

      // CRITICAL: no modulo here (prevents wrap jump that looks like reversal)
      // stroke-dashoffset supports large values; keeping it monotonic = smooth.
      const dashOffset = -(t.start + (progressPx * dir));
      t.el.setAttribute("stroke-dashoffset", dashOffset);

      if(progressPx >= t.lapPx){
        try{ svg.removeChild(t.el); }catch(e){}
        tracers.splice(i,1);
      }
    }

    // If we just became empty, direction may flip (but only then)
    if(tracers.length === 0) maybeFlipDirectionWhenEmpty();

    requestAnimationFrame(tick);
  }

  function start(){
    const now = performance.now();
    // desync per card so left/right don't look mirrored in spawn timing
    nextSpawnAt = now + rand(380, 1500);
    requestAnimationFrame(tick);
  }

  // robust observers
  if(window.ResizeObserver) new ResizeObserver(()=>applyGeometry()).observe(card);
  window.addEventListener("resize", applyGeometry, {passive:true});
  window.addEventListener("orientationchange", applyGeometry, {passive:true});
  document.addEventListener("visibilitychange", ()=>{ if(!document.hidden) setTimeout(applyGeometry, 60); });

  // initial geometry kicks
  applyGeometry();
  setTimeout(applyGeometry, 50);
  setTimeout(applyGeometry, 250);
  setTimeout(applyGeometry, 800);

  return { start };
}

let started=false;
function startEngines(){
  if(started) return;
  started=true;

  const left = createCardEngine({
    card: document.getElementById("cardLeft"),
    svg:  document.getElementById("svgLeft"),
    base: document.getElementById("baseLeft"),
    defaultDir: +1  // left defaults clockwise
  });

  const right = createCardEngine({
    card: document.getElementById("cardRight"),
    svg:  document.getElementById("svgRight"),
    base: document.getElementById("baseRight"),
    defaultDir: -1  // right defaults counterclockwise
  });

  left.start();
  right.start();
}
</script>
</body>
</html>
